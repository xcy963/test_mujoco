
    auto kinematics =std::make_shared<hitcrt::homework_kinematics>();
    auto t_mat = kinematics->forward_kinematics(std::vector<double>(7,0.0));//初始的

    auto center = t_mat.translation() - t_mat.rotation().col(2) * 0.120;
    Eigen::Vector3d axis = t_mat.rotation().col(1);  // Y 轴方向
    axis.normalize();
            // 4. 起始点的平移 & 转动
    Eigen::Vector3d p0 = t_mat.translation();   // 当前末端位置
    Eigen::Matrix3d R0 = t_mat.rotation();      // 当前末端姿态

    // 5. 预先把起始相对向量算出来：从圆心指向末端
    Eigen::Vector3d r0 = p0 - center;
    std::vector<std::vector<double>> tra;
    tra.reserve(51);
    const int N = 180;
    for (int index = 0; index <= N; ++index) {
        double ratio = static_cast<double>(index) / N;
        double theta = ratio * M_PI / 2.0;   // 0 -> 90deg

        // 绕指定轴旋转 theta（Rodrigues / AngleAxis）
        Eigen::AngleAxisd aa(theta, axis);
        Eigen::Matrix3d R_rot = aa.toRotationMatrix();

        // 6.1 末端位置：把 r0 绕轴转，然后加回圆心
        Eigen::Vector3d p = R_rot * r0 + center;

        // 6.2 末端姿态：整个工具坐标系一起绕轴转
        Eigen::Matrix3d R = R_rot * R0;

        // 6.3 组合成一个目标位姿 T_i
        Eigen::Isometry3d T_i = Eigen::Isometry3d::Identity();
        T_i.linear()      = R;
        T_i.translation() = p;

        // 6.4 逆解：从 T_i 得到关节角
        std::vector<double> q = kinematics->inverse_kinematics(T_i);

        // 只取前 6 个关节写入 tra
        std::vector<double> q6(6);
        for (int j = 0; j < 6; ++j) {
            q6[j] = q[j];
        }
        tra.push_back(q6);
    }


    auto setJointTargetByActuator = [](mjModel* m, mjData* d,
                                    const char* actuator_name,
                                    double q_rad) {
        // 1) 执行器名 -> 执行器 id
        int aid = mj_name2id(m, mjOBJ_ACTUATOR, actuator_name);
        if (aid < 0) {
            std::cerr << "[warn] actuator '" << actuator_name << "' not found in model\n";
            return;
        }

        // 2) 根据 ctrlrange 做一下限幅
        double lo = m->actuator_ctrlrange[2 * aid + 0];
        double hi = m->actuator_ctrlrange[2 * aid + 1];

        // 如果没设置 ctrlrange，MuJoCo 里会是 (0,0)，可以选择不 clamp 或者跳过
        if (lo < hi) {
            if (q_rad < lo) q_rad = lo;
            if (q_rad > hi) q_rad = hi;
        }

        // 3) 把目标角度写到 ctrl
        d->ctrl[aid] = q_rad;
    };
    int some_index = 0;
    int direction  = 1;   
    renderer->setControlCallback(
        [&](mjModel* m, mjData* d, double sim_time) {
                    setJointTargetByActuator(m, d, "Joint2_pos", 0.3);

            // if (tra.empty()) return;

            //     int N = static_cast<int>(tra.size());

            //     const char* joint_names[6] = {
            //         "Joint1_pos", "Joint2_pos", "Joint3_pos",
            //         "Joint4_pos", "Joint6_pos", "Joint7_pos"
            //     };

            //     // 用当前 some_index 的关节角
            //     for (int i = 0; i < 6; ++i) {
            //         setJointTargetByActuator(m, d, joint_names[i], tra[some_index][i]);
            //     }

            //     // 更新索引：按 direction 前进
            //     some_index += direction;

            //     // 到头就掉头（乒乓）
            //     if (some_index >= N) {
            //         some_index = N - 2;  // 刚超过尾巴时，回到倒数第二个
            //         direction  = -1;
            //     } else if (some_index < 0) {
            //         some_index = 1;      // 刚超过头时，回到第二个
            //         direction  = 1;
            //     }
            }


        
    );